static const char *RcsId     = "$Header$";
static const char *TagName   = "$Name$";
static const char *HttpServer= "http://www.esrf.fr/computing/cs/tango/tango_doc/ds_doc/";
//+=============================================================================
//
// file :        AnalogDAQClass.cpp
//
// description : C++ source for the AnalogDAQClass. A singleton
//               class derived from DeviceClass. It implements the
//               command list and all properties and methods required
//               by the AnalogDAQ once per process.
//
// project :     TANGO Device Server
//
// $Author: rsune $
//
// $Revision: 6892 $
//
// $Log$
// Revision 1.4  2007/02/13 12:11:26  srubio
// *** empty log message ***
//
// Revision 1.3  2007/02/13 11:49:24  srubio
// Added Modifications required by Dynamic Attributes specification
//
// Revision 1.2  2007/01/17 14:20:47  srubio
// New attributes, properties and commands
//
// Revision 1.1.1.1  2006/11/22 08:54:24  srubio
// First POGO Release of the Analog I/O Abstract Class
//
//
// copyleft :   European Synchrotron Radiation Facility
//              BP 220, Grenoble 38043
//              FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================


#include <tango.h>

#include <AnalogDAQ.h>
#include <AnalogDAQClass.h>


//+----------------------------------------------------------------------------
/**
 *	Create AnalogDAQClass singleton and return it in a C function for Python usage
 */
//+----------------------------------------------------------------------------
/* commented by zreszela - it was giving compilation errors
                           this is an abstract class
extern "C" {
#ifdef WIN32

__declspec(dllexport)

#endif

	Tango::DeviceClass *_create_AnalogDAQ_class(const char *name) {
		return AnalogDAQ_ns::AnalogDAQClass::init(name);
	}
}
*/


namespace AnalogDAQ_ns
{
//+----------------------------------------------------------------------------
//
// method : 		ExportFileCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *ExportFileCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "ExportFileCmd::execute(): arrived" << endl;

	Tango::DevString	argin;
	extract(in_any, argin);

	return insert((static_cast<AnalogDAQ *>(device))->export_file(argin));
}

//+----------------------------------------------------------------------------
//
// method : 		ImportFileCmd::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *ImportFileCmd::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "ImportFileCmd::execute(): arrived" << endl;

	Tango::DevString	argin;
	extract(in_any, argin);

	return insert((static_cast<AnalogDAQ *>(device))->import_file(argin));
}

//+----------------------------------------------------------------------------
//
// method : 		StopClass::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *StopClass::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "StopClass::execute(): arrived" << endl;

	((static_cast<AnalogDAQ *>(device))->stop());
	return new CORBA::Any();
}

//+----------------------------------------------------------------------------
//
// method : 		StartClass::execute()
// 
// description : 	method to trigger the execution of the command.
//                PLEASE DO NOT MODIFY this method core without pogo   
//
// in : - device : The device on which the command must be excuted
//		- in_any : The command input data
//
// returns : The command output data (packed in the Any object)
//
//-----------------------------------------------------------------------------
CORBA::Any *StartClass::execute(Tango::DeviceImpl *device,const CORBA::Any &in_any)
{

	cout2 << "StartClass::execute(): arrived" << endl;

	((static_cast<AnalogDAQ *>(device))->start());
	return new CORBA::Any();
}



//+----------------------------------------------------------------------------
//
// method : 		AnalogDAQClass::AnalogDAQClass(string &s)
// 
// description : 	constructor for the AnalogDAQClass
//
// in : - s : The class name
//
//-----------------------------------------------------------------------------
AnalogDAQClass::AnalogDAQClass(string &s):DeviceClass(s)
{

	cout2 << "Entering AnalogDAQClass constructor" << endl;
	
	cout2 << "Leaving AnalogDAQClass constructor" << endl;

}
//+----------------------------------------------------------------------------
//
// method : 		AnalogDAQClass::command_factory
// 
// description : 	Create the command object(s) and store them in the 
//			command list
//
//-----------------------------------------------------------------------------
void AnalogDAQClass::command_factory()
{
	command_list.push_back(new StartClass("Start",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new StopClass("Stop",
		Tango::DEV_VOID, Tango::DEV_VOID,
		"",
		"",
		Tango::OPERATOR));
	command_list.push_back(new ImportFileCmd("ImportFile",
		Tango::DEV_STRING, Tango::DEV_BOOLEAN,
		"File Name",
		"Ok",
		Tango::OPERATOR));
	command_list.push_back(new ExportFileCmd("ExportFile",
		Tango::DEV_STRING, Tango::DEV_BOOLEAN,
		"File Name",
		"Ok",
		Tango::OPERATOR));

	//	add polling if any
	for (unsigned int i=0 ; i<command_list.size(); i++)
	{
	}
}
//+----------------------------------------------------------------------------
//	Method: AnalogDAQClass::attribute_factory(vector<Tango::Attr *> &att_list)
//-----------------------------------------------------------------------------
void AnalogDAQClass::attribute_factory(vector<Tango::Attr *> &att_list)
{
	//	Attribute : SampleRate
	SampleRateAttrib	*sample_rate = new SampleRateAttrib();
	Tango::UserDefaultAttrProp	sample_rate_prop;
	sample_rate_prop.set_label("SampleRate");
	sample_rate_prop.set_description("The sampling frequency used by the device.\n");
	sample_rate->set_default_properties(sample_rate_prop);
	sample_rate->set_memorized();
	sample_rate->set_memorized_init(true);
	att_list.push_back(sample_rate);

	//	Attribute : ChannelSamplesPerTrigger
	ChannelSamplesPerTriggerAttrib	*channel_buffer_size = new ChannelSamplesPerTriggerAttrib();
	Tango::UserDefaultAttrProp	channel_buffer_size_prop;
	channel_buffer_size_prop.set_label("ChannelSamplesPerTrigger");
	channel_buffer_size_prop.set_description("Size of the buffer used for each channel by this tango device.");
	channel_buffer_size->set_default_properties(channel_buffer_size_prop);
	channel_buffer_size->set_memorized();
	channel_buffer_size->set_memorized_init(true);
	att_list.push_back(channel_buffer_size);

	//	Attribute : NumOfTriggers
	NumOfTriggersAttrib	*num_of_shots = new NumOfTriggersAttrib();
	Tango::UserDefaultAttrProp	num_of_shots_prop;
	num_of_shots_prop.set_label("NumOfTriggers");
	num_of_shots_prop.set_description("The number of times that the entire buffer will be processed. It can be acquired/generated only one time if the value is 1, only for 5 times or continuously if the value is -1 (understood as infinite). \nIts behavior will change depending of the selected TriggerMode.");
	num_of_shots->set_default_properties(num_of_shots_prop);
	num_of_shots->set_memorized();
	num_of_shots->set_memorized_init(true);
	att_list.push_back(num_of_shots);

	//	Attribute : MaxRefSource
	MaxRefSourceAttrib	*max_ref_source = new MaxRefSourceAttrib();
	Tango::UserDefaultAttrProp	max_ref_source_prop;
	max_ref_source_prop.set_label("MaxRefSource");
	max_ref_source_prop.set_description("Maximum reference source value (rel. to Units Prop.)\n");
	max_ref_source->set_default_properties(max_ref_source_prop);
	max_ref_source->set_memorized();
	max_ref_source->set_memorized_init(true);
	att_list.push_back(max_ref_source);

	//	Attribute : MinRefSource
	MinRefSourceAttrib	*min_ref_source = new MinRefSourceAttrib();
	Tango::UserDefaultAttrProp	min_ref_source_prop;
	min_ref_source_prop.set_description("Minimum reference source value (rel. to Units Prop.)\nThe Bipolar Range, Internal Reference and Reference Source Value can be deprecated, so they are more specific than needed. I think that it’s better to use two values and allow asymmetric reference settings by default.");
	min_ref_source->set_default_properties(min_ref_source_prop);
	min_ref_source->set_memorized();
	min_ref_source->set_memorized_init(true);
	att_list.push_back(min_ref_source);

	//	Attribute : TriggerSources
	TriggerSourcesAttrib	*trigger_sources = new TriggerSourcesAttrib();
	Tango::UserDefaultAttrProp	trigger_sources_prop;
	trigger_sources_prop.set_description("An identifier to the available trigger signals used by the device, NULL for internal or software triggering.");
	trigger_sources->set_default_properties(trigger_sources_prop);
	trigger_sources->set_memorized();
	trigger_sources->set_memorized_init(true);
	att_list.push_back(trigger_sources);

	//	Attribute : TriggerMode
	TriggerModeAttrib	*trigger_mode = new TriggerModeAttrib();
	Tango::UserDefaultAttrProp	trigger_mode_prop;
	trigger_mode_prop.set_description("A table ought to be defined with the possible triggering modes (Start, Start/Stop, Gate, FiniteStarts, etc ...). ");
	trigger_mode->set_default_properties(trigger_mode_prop);
	trigger_mode->set_memorized();
	trigger_mode->set_memorized_init(true);
	att_list.push_back(trigger_mode);

	//	Attribute : BufferPeriod
	BufferPeriodAttrib	*buffer_period = new BufferPeriodAttrib();
	Tango::UserDefaultAttrProp	buffer_period_prop;
	buffer_period_prop.set_description("Just an Interface between BufferSize and its equivalent in time units (depending of SampleRate). BufferSize and BufferPeriod will be the same internal variable that could be readed/modified using different unit  (Samples or milliseconds)  from two different attributes.");
	buffer_period->set_default_properties(buffer_period_prop);
	buffer_period->set_memorized();
	buffer_period->set_memorized_init(true);
	att_list.push_back(buffer_period);

	//	Attribute : BufferedChannelsList
	BufferedChannelsListAttrib	*buffered_channels_list = new BufferedChannelsListAttrib();
	Tango::UserDefaultAttrProp	buffered_channels_list_prop;
	buffered_channels_list_prop.set_description("Array or Spectrum with the Identifiers of all channels actually used by this device that are sharing the internal Hardware Buffer (it won’t be equal to the number of channels available). If it is not written it’s understood that all the available channels are used.\nThe Size/Length of this Array/Vector provides us the total number of channels used (and the *Values/*DATA Attributes Dimensions). It would be something like: [“ai2”,”ai3”,”ai5”] , each of strings identifying the channels used in the same order.");
	buffered_channels_list->set_default_properties(buffered_channels_list_prop);
	att_list.push_back(buffered_channels_list);

	//	Attribute : RawDATA
	RawDATAAttrib	*raw_data = new RawDATAAttrib();
	Tango::UserDefaultAttrProp	raw_data_prop;
	raw_data_prop.set_description("Raw Binary values acquired directly from the DAQ conversion. Read/Write permissions will depend of the Analog Input/Output Property implementation. \nThe Dimensions of this attribute will be determined by ChannelSamplesPerTrigger and the BufferedChannelsList Size, so it could be resized ’on the fly’.");
	raw_data->set_default_properties(raw_data_prop);
	att_list.push_back(raw_data);

	//	Attribute : DoubleDATA
	DoubleDATAAttrib	*double_data = new DoubleDATAAttrib();
	Tango::UserDefaultAttrProp	double_data_prop;
	double_data_prop.set_description("Just an interface to convert each value of the RawDATA image to its equivalent normalized inside the Reference Source Range specified (MaxSourceRef and MinSourceRef Attributes).");
	double_data->set_default_properties(double_data_prop);
	att_list.push_back(double_data);

	//	Attribute : FileName
	FileNameAttrib	*file_name = new FileNameAttrib();
	file_name->set_memorized();
	file_name->set_memorized_init(true);
	att_list.push_back(file_name);

	//	Attribute : ScalarValue
	ScalarValueAttrib	*scalar_value = new ScalarValueAttrib();
	scalar_value->set_memorized();
	scalar_value->set_memorized_init(true);
	att_list.push_back(scalar_value);

	//	Attribute : ChannelSpectrum
	ChannelSpectrumAttrib	*channel_spectrum = new ChannelSpectrumAttrib();
	att_list.push_back(channel_spectrum);

}

}	// namespace
